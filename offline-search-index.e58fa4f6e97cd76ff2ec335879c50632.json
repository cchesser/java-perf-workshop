





















[{"body":"Java Development Kit Install a Java Development Kit from Oracle or Open JDK\n Oracle OpenJDK  Maven Install the latest available Maven\nJDK Mission Control Install JDK mission control from Oracle Mirror\nVisual VM Install the standalone version of Visual VM\nEclipse MAT Install the standalone version of Eclipse MAT\n","categories":"","description":"Instructions for acquiring the sofware needed for the workshop.\n","excerpt":"Instructions for acquiring the sofware needed for the workshop.\n","ref":"/docs/prereqs/","tags":"","title":"Prerequisites"},{"body":"In this section we‚Äôre going to spin up the services needed for the workshop.\nNote Make sure you‚Äôve gone through the Prerequisites  Service The web service is a simple dropwizard server, which has a single API to search for talks from kcdc.info, and returns results about these talks.\nRunning Prerequisites:\n Maven Java JDK  Assemble the service:\nmvn clean package üí° If you have issues with building it locally due to your setup, you can download the server assembly here.\nStart the workshop service:\njava -jar java-perf-workshop-server/target/java-perf-workshop-server-1.1.0-SNAPSHOT.jar server server.yml Mocking Service Dependency To simulate responses of kcdc.info (as the service may change over time), we will first run a mock instance of this service using WireMock.\nGo ahead and start another terminal session where we will run another service to mock a remote dependency of the workshop service. Navigate to the same directory where you cloned this repository, then execute the following commands:\nmvn dependency:copy -Dartifact=com.github.tomakehurst:wiremock-standalone:2.24.1 -Dmdep.stripVersion=true -DoutputDirectory=. Run the mock service, which will provide the essential end-points to support the service we will be testing:\njava -jar wiremock-standalone.jar --port 9090 --root-dir java-perf-workshop-server/src/test/resources Alternatively, you can run the mockservice.sh script which will do both commands, ie: sh mockservice.sh\nConfiguration Example configuration of service:\nserver: applicationConnectors: - type: http port: 80 adminConnectors: - type: http port: 8071 requestLog: timeZone: UTC appenders: - type: file currentLogFilename: /var/log/java-perf-workshop-server-access.log threshold: ALL archive: true archivedLogFilenamePattern: /var/log/java-perf-workshop-server-access.%d.log.gz archivedFileCount: 5 logging: level: INFO appenders: - type: file currentLogFilename: /var/log/java-perf-workshop-server.log threshold: ALL archive: true archivedLogFilenamePattern: /var/log/java-perf-workshop-server-%d.log archivedFileCount: 5 timeZone: UTC Testing The service will return back results from the KCDC website on sessions that are available which contain a substring in their title, abstract, or tags. Example:\nhttp://localhost:8080/search?q=clojure\nExample results:\n{ \"results\" : [ { \"title\" : \"Concurrency Options on the JVM\", \"presenter\" : \"Jessica Kerr\" }, { \"title\" : \"Fast, Parallel, or Reliable: Pick 3, a tour of Elixir\", \"presenter\" : \"Jordan Day\" } ] } Troubleshooting If you get a 500 error message when trying to test the service, verify that the wiremock server is running.\n{ \"code\" : 500, \"message\" : \"There was an error processing your request. It has been logged (ID d8998189f8d4ee8c).\" } Reference  KCDC 2015 workshop slides  ","categories":"","description":"Instructions for setting up the workshop\n","excerpt":"Instructions for setting up the workshop\n","ref":"/docs/setup/","tags":"","title":"Setup"},{"body":"Java Flight Recorder The Java Flight Recorder (JFR) is a very low overhead profiling and diagnostics tool. It was inherited from the JRockit JVM, and originally was offered as part of the HotSpot JVM. It is designed to be ‚Äúblack box‚Äù data recorder of the the run-time, which can be used in production environments, making it an attractive tool for profiling code since it has low overhead on the JVM.\nNewer versions of JMC are developed as part of the OpenJDK Mission Control project.\nTo enable the Flight Recorder on the JVM, the following options need to be included on the JVM:\n-XX:+UnlockCommercialFeatures -XX:+FlightRecorder ‚ùó Notice that you have to include -XX:+UnlockCommercialFeatures first in the options listing. This is because using Flight Recorder is a feature that requires additional licensing when used in production environments. One of the following licenses is required in order to utilize this in a production environment.\n Oracle Java SE Advanced Oracle Java SE Suite  However, you may use this in non-production environments without additional licensing.\nHigher Fidelity on Method Profiling To get better fidelity on method profiling, include the following options which will enable the compiler to include additional metadata on non-safe code points. This is helpful, as sometimes the metadata will not fully resolve to the correct line in the code.\n-XX:+UnlockDiagnosticVMOptions -XX:+DebugNonSafepoints Java Mission Control We will be using Java Mission Control to monitor and evaluate the Java flight recordings. To start up Java Mission Control, simply executing the following in your console:\njmc üí° In order to be able to invoke jmc (Java Mission Control) from your console, it assumes $JAVA_HOME/bin is on your $PATH. If it is not included, go ahead and update your profile to include this so you can easily invoke jmc from your terminal.\nStart Service with JFR Let‚Äôs start profiling our service. Start the service up by enabling JFR:\nStart from the console # Note, if you are running this server from a different folder, consider changing the SERVER_HOME SERVER_HOME=java-perf-workshop-server/target java -XX:+UnlockCommercialFeatures -XX:+FlightRecorder -XX:+UnlockDiagnosticVMOptions -XX:+DebugNonSafepoints -jar $SERVER_HOME/java-perf-workshop-server-1.1.0-SNAPSHOT.jar server server.yml üí° Starting with Java Mission Control 5.5 (included in Oracle Java 8u40), you no longer have to enable JFR prior to capturing the recording (it will dynamically enable it, after prompting about it).\nStart Flight Recording from JMC This will open a window where you apply some settings for the recording. First select that you want this to be a Continuous recording and for Event settings, we will import a template to get some consistent settings for profiling. Within the Template Manager, select Import Files‚Ä¶ and import the open_jdk_9_.jfc included in the content/docs/jmc folder. It should appear as Java Performance Workshop JDK9+ Profile. Select this as the Event Settings and then click on Finish.\nFor reference, these are the options for the template.\nFirst select that you want this to be a Continuous recording and for Event settings we will use Profiling on Server.\nOnce your flight recording is being captured in a Continuous recording, it will show a ‚àû.\nüí° You can see the JFR templates (continuous / profile) which are shipped as part of the JRE in: $JAVA_HOME/jre/lib/jfr. These become helpful if you are wanting to compare your settings to some of the standard ones.\nGenerate HTTP traffic on service We will want to generate some traffic on the service to measure some general characteristics of the service:\n Throughput (requests per second) Response time Trend of response time over time  By generating traffic on service, this gives us baseline activity in the JVM to start evaluating the flight recording.\nBasic test This service under test, is a simple web service which provides results based on a search API. When interacting with the service, you can simply supply a HTTP GET on the search resource with a query parameter (‚Äòq‚Äô) with the term that you are searching for. It will then return KCDC‚Äôs 2015 sessions that contain that term. Example:\ncurl \"http://localhost:8080/search?q=jvm\" { \"results\" : [ { \"title\" : \"Concurrency Options on the JVM\", \"presenter\" : \"Jessica Kerr\", \"sessionType\" : \"Regular Session\" }, { \"title\" : \"Exploring the Actor Model with Akka.NET\", \"presenter\" : \"Robert Macdonald Smith\", \"sessionType\" : \"Regular Session\" }, { \"title\" : \"What's in your JVM?\", \"presenter\" : \"Carl Chesser\", \"sessionType\" : \"4-Hour Workshop\" } ] } Using Apache Benchmark We can utilize Apache Benchmark to generate traffic on the service From the console, we will execute the following to generate traffic against our service. Note, we will use a very basic search of just ‚Äúa‚Äù, since this will generate more results.\nab -n 1000 -c 15 \"http://localhost:8080/search?q=a\" Using loadtest An alternative to Apache Benchmark, is loadtest (a node.js equivalent). To install:\nsudo npm install -g loadtest Then you can execute similarly:\nloadtest -n 1000 -c 15 \"http://localhost:8080/search?q=a\" Using gatling Alternatively, you can use gatling (a performance library with a scala dsl ).\nThis should launch the WorkshopSimulation.\nmvn -f java-perf-workshop-tester/ gatling:test Sample output while running:\n[~/java-perf-workshop/java-perf-workshop-tester]$ mvn gatling:test [INFO] Scanning for projects... [INFO] [INFO] ------------------------------------------------------------------------ [INFO] Building java-perf-workshop-tester 1.1.0-SNAPSHOT [INFO] ------------------------------------------------------------------------ [INFO] [INFO] --- gatling-maven-plugin:2.2.4:test (default-cli) @ java-perf-workshop-tester --- 19:12:16,662 |-INFO in ch.qos.logback.classic.LoggerContext[default] - Could NOT find resource [logback-test.xml] 19:12:16,663 |-INFO in ch.qos.logback.classic.LoggerContext[default] - Could NOT find resource [logback.groovy] 19:12:16,663 |-INFO in ch.qos.logback.classic.LoggerContext[default] - Found resource [logback.xml] at [file:/J:/Workspaces/java-perf-workshop/java-perf-workshop-tester/target/test-classes/logback.xml] 19:12:16,663 |-WARN in ch.qos.logback.classic.LoggerContext[default] - Resource [logback.xml] occurs multiple times on the classpath. 19:12:16,663 |-WARN in ch.qos.logback.classic.LoggerContext[default] - Resource [logback.xml] occurs at [file:/J:/Workspaces/java-perf-workshop/java-perf-workshop-tester/target/test-classes/logback.xml] 19:12:16,663 |-WARN in ch.qos.logback.classic.LoggerContext[default] - Resource [logback.xml] occurs at [jar:file:/C:/Users/JMonterrubio/.m2/repository/io/gatling/gatling-maven-plugin/2.2.4/gatling-maven-plugin-2.2.4.jar!/logback.xml] 19:12:16,727 |-INFO in ch.qos.logback.classic.joran.action.ConfigurationAction - debug attribute not set 19:12:16,731 |-INFO in ch.qos.logback.core.joran.action.AppenderAction - About to instantiate appender of type [ch.qos.logback.core.ConsoleAppender] 19:12:16,737 |-INFO in ch.qos.logback.core.joran.action.AppenderAction - Naming appender as [CONSOLE] 19:12:16,742 |-INFO in ch.qos.logback.core.joran.action.NestedComplexPropertyIA - Assuming default type [ch.qos.logback.classic.encoder.PatternLayoutEncoder] for [encoder] property 19:12:16,781 |-INFO in ch.qos.logback.classic.joran.action.RootLoggerAction - Setting level of ROOT logger to WARN 19:12:16,782 |-INFO in ch.qos.logback.core.joran.action.AppenderRefAction - Attaching appender named [CONSOLE] to Logger[ROOT] 19:12:16,782 |-INFO in ch.qos.logback.classic.joran.action.ConfigurationAction - End of configuration. 19:12:16,783 |-INFO in ch.qos.logback.classic.joran.JoranConfigurator@7a0ac6e3 - Registering current configuration as safe fallback point Simulation cchesser.javaperf.workshop.WorkshopSimulation started... Stop Flight Recorder After you have played traffic through the service, you can then stop your flight recording from JMC.\nThen dump the whole recording.\nThe Flight Recording From a Java Flight Recording, there are several categories of information (pages) you can view from JMC:\n Code Information:  Method Profiling: Provides information about specific method runs and how long each run took, identifying hot spots in your code base. Exceptions: Displays Exceptions and Errors thrown and which methods threw them. Viewing exceptions requires editing the settings to also capture Exceptions.   Thread information:  Threads: Provides a snapshot of all the threads that belong to the Java Application and the thread activity. Lock Instances: Provides further details on threads by specifying lock information, showing which threads request and which threads take a particular lock. Thread Dump: Provides period thread dump information.   Memory Information:  Memory: Represents heap memory usage of the JVM.   IO Information:  File I/O: Displays File costs and behaviors Socket I/O: Displays Network costs and behaviors   JVM Internals:  Garbage Collections: Displays heap usage compared to pause times as well as GC events. Compliations: Provides details on code compilation. TLAB Allocations: Displays Thread Local Allocation Buffers.   System Information:  Processes: See other processes on the system and what is competing for resources. Environment: Provides information about the environment in which the recording was made. System Properties: Show properties passed on to the JVM.   Events: Event Browser: View detailed log of the events within the JVM. You can use this page to further filter down on events across all the pages in the recording.  Note Feel free to reference the additional resources as you navigate through the sections.   ¬†¬†Up Next In the next section, we'll find out more about what our methods are doing. Method Profiling   ","categories":"","description":"Introduction into Java Mission Control with Flight Recorder\n","excerpt":"Introduction into Java Mission Control with Flight Recorder\n","ref":"/docs/jmc/_intro_jmc7/","tags":"","title":"Introduction"},{"body":"In the following sections, we are going to do some analysis of the JVM‚Äôs heap dump.\nNote Make sure you‚Äôve gone through the Prerequisites  First, we‚Äôll need to capture a heap dump:\n Capturing a Heap Dump  We will then go through three common tools in which we can do some analysis of a heap dump. All of which are free. üòÉ\n JOverflow Analysis Eclipse MAT VisualVM  We will then tie all our knowledge together and attempt to solve a quick challenge:\n Memory Challenge  ¬† ¬†¬†Up Next In the next section, we'll learn how to acquire a Heap Dump. Capturing Heap Dumps   ","categories":"","description":"Analyzing the heap of the JVM.","excerpt":"Analyzing the heap of the JVM.","ref":"/docs/memory/heap/","tags":"","title":"Memory Heap Analysis"},{"body":"This first part of the workshop, we will begin to learn about looking at the JVM from its native perspective, and begin obtaining JVM based information to correlate to it‚Äôs native representation.\ntop A very common utility as to monitor processes in Linux. For our case, we will want to monitor our JVM process. When just executing top, you will see all processes on the host:\ntop - 05:32:51 up 8 min, 1 user, load average: 0.05, 0.12, 0.06\rTasks: 62 total, 1 running, 61 sleeping, 0 stopped, 0 zombie\rCpu(s): 11.2%us, 0.7%sy, 0.0%ni, 87.8%id, 0.0%wa, 0.0%hi, 0.0%si, 0.3%st\rMem: 1020184k total, 466284k used, 553900k free, 17740k buffers\rSwap: 0k total, 0k used, 0k free, 289500k cached\rPID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND\r6730 ec2-user 20 0 2246m 108m 13m S 10.3 10.9 0:14.11 java\r1 root 20 0 19596 1616 1292 S 0.0 0.2 0:00.56 init\r2 root 20 0 0 0 0 S 0.0 0.0 0:00.00 kthreadd\r3 root 20 0 0 0 0 S 0.0 0.0 0:00.02 ksoftirqd/0\r4 root 20 0 0 0 0 S 0.0 0.0 0:00.00 kworker/0:0\r5 root 0 -20 0 0 0 S 0.0 0.0 0:00.00 kworker/0:0H\r6 root 20 0 0 0 0 S 0.0 0.0 0:00.04 kworker/u30:0\r7 root 20 0 0 0 0 S 0.0 0.0 0:00.27 rcu_sched\r8 root 20 0 0 0 0 S 0.0 0.0 0:00.00 rcu_bh\r9 root RT 0 0 0 0 S 0.0 0.0 0:00.00 migration/0\rYou can switch in this view to also view the native threads, by hitting Shift+H.\ntop - 05:34:15 up 9 min, 1 user, load average: 0.01, 0.09, 0.05\rTasks: 101 total, 1 running, 100 sleeping, 0 stopped, 0 zombie\rCpu(s): 4.0%us, 0.3%sy, 0.0%ni, 95.7%id, 0.0%wa, 0.0%hi, 0.0%si, 0.0%st\rMem: 1020184k total, 491176k used, 529008k free, 17804k buffers\rSwap: 0k total, 0k used, 0k free, 312648k cached\rShow threads On\rPID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND\r6736 ec2-user 20 0 2246m 109m 13m S 2.0 11.0 0:05.72 java\r6737 ec2-user 20 0 2246m 109m 13m S 0.3 11.0 0:01.69 java\r6740 ec2-user 20 0 2246m 109m 13m S 0.3 11.0 0:01.67 java\r6746 ec2-user 20 0 2246m 109m 13m S 0.3 11.0 0:00.31 java\r6768 ec2-user 20 0 2246m 109m 13m S 0.3 11.0 0:00.03 java\r6778 ec2-user 20 0 2246m 109m 13m S 0.3 11.0 0:00.08 java\r6777 ec2-user 20 0 15224 1332 1032 R 0.3 0.1 0:00.04 top\r1 root 20 0 19596 1616 1292 S 0.0 0.2 0:00.56 init\r2 root 20 0 0 0 0 S 0.0 0.0 0:00.00 kthreadd\r3 root 20 0 0 0 0 S 0.0 0.0 0:00.02 ksoftirqd/0\r4 root 20 0 0 0 0 S 0.0 0.0 0:00.00 kworker/0:0\rWith these native threads, you can now get better context of what resources are being utilized. To simplify this, you can target top to just watch one parent process and then show threads via:\ntop -H -p \u003cPID\u003e In our earlier example, our PID was 6730. Therefore, this would produce:\n$ top -H -p 6730\rtop - 05:38:05 up 13 min, 1 user, load average: 0.00, 0.05, 0.05\rTasks: 32 total, 0 running, 32 sleeping, 0 stopped, 0 zombie\rCpu(s): 0.0%us, 0.0%sy, 0.0%ni,100.0%id, 0.0%wa, 0.0%hi, 0.0%si, 0.0%st\rMem: 1020184k total, 515940k used, 504244k free, 17932k buffers\rSwap: 0k total, 0k used, 0k free, 336520k cached\rPID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND\r6739 ec2-user 20 0 2246m 110m 13m S 0.3 11.1 0:00.24 java\r6730 ec2-user 20 0 2246m 110m 13m S 0.0 11.1 0:00.00 java\r6731 ec2-user 20 0 2246m 110m 13m S 0.0 11.1 0:01.50 java\r6732 ec2-user 20 0 2246m 110m 13m S 0.0 11.1 0:01.07 java\r6733 ec2-user 20 0 2246m 110m 13m S 0.0 11.1 0:00.00 java\r6734 ec2-user 20 0 2246m 110m 13m S 0.0 11.1 0:00.00 java\r6735 ec2-user 20 0 2246m 110m 13m S 0.0 11.1 0:00.00 java\r6736 ec2-user 20 0 2246m 110m 13m S 0.0 11.1 0:07.33 java\r6737 ec2-user 20 0 2246m 110m 13m S 0.0 11.1 0:01.69 java\r6738 ec2-user 20 0 2246m 110m 13m S 0.0 11.1 0:00.00 java\rTo make a simple standard capture of native threads for diagnostic purposes, you can do the following:\ntop -b -n3 -H -p \u003cPID\u003e This will capture thread iterations of top by capturing threads of the parent process ID. You can then pipe it to a file.\nExample:\ntop -b -n3 -H -p 6730 \u003e jvm_native_threads.log Java Utilities There‚Äôs a couple of java utilities that can also be used to find the PIDs of your running processes.\njps The Java Virtual Machine Process Status Tool can be used to see Java processess.\n$ jps 7241 Jps 6059 java-perf-workshop-server-1.1.0-SNAPSHOT.jar 6925 jar You can get more insight by using some of its flags:\n$ jps -lvm 6059 java-perf-workshop-server/target/java-perf-workshop-server-1.1.0-SNAPSHOT.jar server server.yml 6925 wiremock-standalone.jar --port 9090 --root-dir java-perf-workshop-server/src/test/resources 7582 sun.tools.jps.Jps -lvm -Dapplication.home=/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home -Xms8m jcmd The jcmd utility is an attempt to consolidate other utilities into a single interface.\nRunning the jcmd command should display some of the same information that jps showed us (similar to jps -m):\n$ jcmd\r6059 java-perf-workshop-server/target/java-perf-workshop-server-1.1.0-SNAPSHOT.jar server server.yml\r6925 wiremock-standalone.jar --port 9090 --root-dir java-perf-workshop-server/src/test/resources\r7838 sun.tools.jcmd.JCmd\rThread Dump To capture a thread dump of the JVM, there are many tools that can achieve this. You can do this over JMX remotely, sending an OS signal (kill -3), or just form the command line (jstack or jcmd). To keep it simple, we will just use jcmd as we will use it later for other diagnostic commands.\njcmd \u003cPID\u003e Thread.print üí° You need to be the same OS user when invoking the command as the target JVM.\nSo, using our earlier example, this would be:\njcmd 6730 Thread.print However, correlating a thread dump to the native thread state requires a minor translation. In your thread dump, the native thread identifier is in hexadecimal, while the native thread identifiers from top are in decimal. Therefore, if you notice a thread spiking in the top view, you would then want to understand what cod it is correlating to. You can do this simply from the command line via:\nprintf \"%x\\n\" \u003cDecimal Thread ID\u003e Example:\n$ printf \"%x\\n\" 6736 1a50 $ I can then cross reference this thread to my thread dump via the nid (native thread ID) field:\n\"C2 CompilerThread0\" #5 daemon prio=9 os_prio=0 tid=0x00007efda40d4000 nid=0x1a50 waiting on condition [0x0000000000000000]\rjava.lang.Thread.State: RUNNABLE\rAn alternative tool fastthread.io also has a blog on other ways to capture a thread dump\njcmd PerfCounter A very simple and quick collection of stats on a JVM can be collected via:\njcmd \u003cPID\u003e PerfCounter.print Generally the information in this file may or may not indicate the actual problem, but can provide more context in a concise text file of what all has occurred in the life of that JVM. One simple set of counters related to threads are:\njava.threads.daemon=20\rjava.threads.live=26\rjava.threads.livePeak=38\rjava.threads.started=697\rstrace In some rare cases, you may need to figure out what system calls your JVM is doing. One way to do this on several flavors of Linux, is to use strace.\nstrace -f -v -p \u003cPID\u003e Example:\nstrace -f -v -p 6730 Example output:\n[pid 6741] futex(0x7efda4587228, FUTEX_WAKE_PRIVATE, 1 \u003cunfinished ...\u003e\r[pid 6740] write(1, \"DEBUG [2015-06-24 05:50:34,727] \"..., 168 \u003cunfinished ...\u003e\r[pid 6830] gettimeofday( \u003cunfinished ...\u003e\rFrom the write call, we can see it is tied to the thread ID 6740. If we translate it to x1a54, which is then tied to this logging thread in the JVM.\n\"AsyncAppender-Worker-Thread-1\" #9 daemon prio=5 os_prio=0 tid=0x00007efda44d1800 nid=0x1a54 waiting on condition [0x00007efd941f0000]\rjava.lang.Thread.State: WAITING (parking)\rat sun.misc.Unsafe.park(Native Method)\r- parking to wait for \u003c0x00000000f5d38d20\u003e (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)\rat java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)\rat java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)\rYou will notice that the system calls are quite noisy with the JVM, but this type of troubleshooting can greatly help when the JVM is getting ‚Äúhung‚Äù or hitting limits by the OS and it isn‚Äôt clear from the exception that you are seeing what it is getting restricted on.\n","categories":"","description":"Initial look at the JVM from its native perspective.\n","excerpt":"Initial look at the JVM from its native perspective.\n","ref":"/docs/intro/","tags":"","title":"Process and Threads"},{"body":"","categories":"","description":"","excerpt":"","ref":"/docs/","tags":"","title":"Workshop"},{"body":"You may be aware by now, there are many different ways of getting data from the JVM. Here are just a few ways to get heap dump of the JVM.\njcmd With jcmd, you have the ability to invoke the GC.heap_dump command. This requires that you are running as the same OS user as the target JVM process.\njcmd \u003cPID\u003e GC.heap_dump my_little_heap_dump.hprof Note: If a full path is not specified, the heap_dump will be created relative to the location from where the process was started (when generated with jcmd)\njmap A more traditional approach is using jmap and invoking the command on the target process.\njmap -dump:format=b,file=my_little_heap_dump.hprof \u003cPID\u003e Core Dump You can also use jmap to extract a heap dump from a core dump on the process:\nsudo gdb --pid=\u003cPID\u003e gcore /tmp/jvm.core detach quit jmap -dump:format=b,file=my_little_heap_dump.hprof /usr/bin/java /tmp/jvm.core üí° Capturing a heap dump from a core dump on Java 8, you may run into this issue: JDK-8073606.\nHotSpot Diagnostic MBean You can capture a heap dump by invoking a diagnostic MBean which is included in the Oracle JDK. You can do so by opening your favorite MBean browser (ex. jconsole, jmc) and invoke the com.sun.management.HotSpotDiagnostic. The arguments are:\n Filename of the heap dump that will be created. üí° Note, it will be created with file ownership of the hosting JVM process. Indicator to dump all live object (true will dump only live objects)  ¬† ¬†¬†Up Next In the next section, we'll start analyzing our heap dump with JOverflow. JOverflow   ","categories":"","description":"Different ways to capture a heap dump.","excerpt":"Different ways to capture a heap dump.","ref":"/docs/memory/capturing/","tags":"","title":"Capturing Heap Dumps"},{"body":"Our first look at the recording will start with finding out where we might be spending time with our code.\nMethod Profiling Page We‚Äôll start by taking a look at the detailed Method Profiling Page. This page displays how often a specific method is ran based on sampling.\nNote This page is a little bit difficult to use in JMC7, planned improvements for the data visualization will come in JMC8, see JMC#165  By default, this view groups threads by method, but you can also include the line number for each method. This can be accomplishbed by selecting the View Menu option and going to Distinguish Frames By and selecting Line Number.\nüí° Generally, you don‚Äôt need this, as it can be quite apparent by the base method being invoked where the cost is at. Though, it may be helpful to include in some contexts.\nNote Remember that this is just a sampling view, and does not mean that only a small amount of methods were hit. We‚Äôll be able to visualize more of this info in the following part.  Java Application Navigate to the Java Application page. This page provides an overview of the state of the JVM and collates information from a couple of the dedicated pages.\nUsing the checkboxes on the right of the Graph, select only Method Profiling to narrow down the set of events on the graph:\nThe Stack Trace view from this page can give you a better count of sampled methods (not just the ones from a specific Method Profiling event)\nThis information is the equivalent of the Hot Methods tab in JMC 5, see forum discussion.\nWe can then use this information to correlate what is happening in our code:\n Explore  Walk around to look at other areas where you are spending time in your code.  In many cases you find that there are very expensive areas of code that you cannot change (as you may not own it), but you can dictate whether or not it should be executed (or executed as frequently.     Follow Ups  Is there any method that stands out to you that might be unnecessarily called?   ¬†¬†Up Next In the next section, we'll look at the Exceptions thrown by our application. Exceptions   ","categories":"","description":"Gather context of where we spend time in our code\n","excerpt":"Gather context of where we spend time in our code\n","ref":"/docs/jmc/method_profiling/","tags":"","title":"Method Profiling"},{"body":"In this section we‚Äôll dive into the Exceptions page and find out what information we can learn from it. Start by selecting the Exceptions page from the Outline.\nThis page offers the following sections:\n Overview: You can get Exceptions by Class and Count Message: View the detail messages for all exceptions and errors. Timeline/Event Log: View when a particular exception was thrown. StackTrace: Identify where the exception was thrown from.  .\nYou can select an exception from the table to filter the information to that particular exception. You could also filter by a particular exception message.\n Explore NullPointerExceptions are a familiar exception you deal with in Java, and often times indicate a programming error. Other exception types often point to a common symptom.\n Follow Ups  What are the exceptions that are getting generated the most?  What stack traces are the contributor?   Can you find any areas in our code where we may have made an incorrect assumption regarding nullability?  Are there any other areas in our code where we might have made an incorrect assumption based on an exception‚Äôs class?   Are there any exceptions that might indicate a problem with our dependencies?  ¬† ¬†¬†Up Next In the next section, we'll look at the Threads used by our application. Threads   ","categories":"","description":"Find the exceptional cases in our application.\n","excerpt":"Find the exceptional cases in our application.\n","ref":"/docs/jmc/exceptions/","tags":"","title":"Exceptions"},{"body":"Included in JDK Mission Control is a plugin that used to be a separate instance, the JOverflow Heap Analyzer. This plugin now adds a context menu selection to Dump Heap of JVMs from the JVM Browser.\nJOverflow is a great tool to start our analysis with since it is tailored to identifying common anti-patterns present in most heap dumps. This should give us an idea of the kinds of problems we can see in our JVMs.\nAnti-Patterns Here is a listing of some the patterns that JOverflow identifies:\n Empty Unused Collections: Empty collection, where modification count == 0. Empty Used Collections: Empty collection, where modification count != 0. Small Sparse: Only for array-based, where less than half the slots are occupied. Small is considered: size \u003c= default (ex. 16 for HashMap). Large Sparse: Only for array-based, where less than half the slots are occupied. Large is considered: Size \u003e default. Boxed: Contains boxed Numbers (ex. java.lang.Integer). Each of these boxed number has overhead as compared to their primitive counterpart due to object references. Small Collections: Collections with 1 to 4 elements. There are fixed costs of collections, which may lend this set of data better hosted in an array vs. a full Java collection type. Vertical Bar Collections: Collection which is a list of lists, where the outer collection is large, and it‚Äôs elements are all small collections (ex. List(1000) of List(100)) Zero Size Arrays: Array where length == 0 (still consumers 12 - 16 bytes). Vertical Bar Arrays: Similar to Vertical Bar Collections, but for arrays. Sparse Arrays: Less than half of the elements are not null. Long Zero Tail Arrays: Ends with a consecutive series of zeros, where the tail length is \u003e= size / 2. Empty Arrays: Only null elements. Duplicate Arrays: Where an array contents are the same in another instance, but they are separate array instances. Duplicate Strings: Same as Duplicate Array, where string1.equals(string2) and string1 != string2.  Reference: JOverflow: Advanced Heap Analysis in Java Mission Control\nFiltering As you play with JOverflow, once you click on something, it will begin filtering down your content. If you wish to reduce down to code that you may own, you can start doing a package filter on the ancestor section.\nIn this example, I want to see duplicate strings for code under cchesser. In this case, I can see that our workshop service has several duplicate strings (as this content is replicated on each object):\n Regular Session 4-Hour Workshop 8-Hour Workshop  However, the number of instances / overhead is extremely low (since this is a small service), it gives you visibility of areas that you could optimize.\nNavigating Since JOverflow‚Äôs mechanism of drilling down is by applying filters, it doesn‚Äôt have an easy way to undo most operations, and instead relies on resetting the state to the unfiltered state. You can undo all operations by using the backwards arrow button:\nInstances We can also use the plugin to drill down a bit into particular instances.\nWe can enable the instances view by navigating to:\n Window \u003e Show View \u003e Other  Selecting JOverflow Instances   Example - Arrays Size 1 In the following example, we‚Äôre going to find:\n Arrays with One Element  Coming from our WorkshopConfiguration   This should filter the Instances view down to that single object.\nExample - Conference Session Details We can use this same mechanism to also explore values of some of the classes we own, in the next example we‚Äôre going to:\n Use All Objects of type Conference Session  Drill down into a couple of the instances   ¬† ¬†¬†Up Next In the next section, we'll continue our analysis in Eclipse MAT. Eclipse MAT   ","categories":"","description":"Heap Analysis using JOverflow","excerpt":"Heap Analysis using JOverflow","ref":"/docs/memory/joverflow/","tags":"","title":"JOverflow"},{"body":" Note Make sure you‚Äôve gone through the Prerequisites  Eclipse Memory Analyzer is a fairly mature tool on analyzing heap dumps. It is a rich tool that includes the abilities to do OQL queries on the heap, general reporting on anti-patterns, and helpful common views (like the dominator tree). Eclipse Memory Analyzer tool is a separate install which can be a standalone install, or it can run as a plugin within Eclipse.\nOpening Heap Dumps After you have it installed, go to File and then Open Heap Dump‚Ä¶ and specify the hprof file that you wish to analyze.\nIndex Files üí° When Eclipse Memory Analyzer loads your hprof file, it will create many other index files to assist in optimally analyzing and navigating through your heap dump. It may make it easier to isolate your prof file in its own directory prior to opening it, based on the secondary files which are created. You can always just delete these files within Eclipse Memory Analyzer by opening the Heap Dump History window, right-clicking the hprof which was previously loaded, and selecting Delete Index Files. Example listing of index files which get generated by suffix:\n .domIn.index .domOut.index .index .o2ret.index .a2s.index .idx.index .inbound.index .o2c.index .o2hprof.index .outbound.index .threads  Analyzing the Heap Dump In the following section, we‚Äôll go through a couple of the views and what sort of data we can gather from them.\nDominator Tree A common first area to look at your heap within Eclipse Memory Analyzer is the dominator tree. From the dominator tree, you can organize by the retained heap size, and then begin drilling down the tree to see the contributors to the largest GC roots.\nHistogram The histogram gives you a quick listing of all the top consumers by type. Typically this is going to provide context of the large consumers based on their ‚Äúlower-level‚Äù types. For example, char[] is a common large contributor, which then will be followed by String which is a type that is predominately weighted by the size of the char[].\nFrom the histogram, we can drill down into particular instances of an object and see what‚Äôs referencing them by right clicking on a row and selecting List Objects \u003e with Incoming References\nThis should let us drill down into an instance and find what exactly is holding on to that specific value:\nSince this view shows references by incoming link, we would read the results as:\n‚Äúangularjs‚Äù is pointed to by the [0] index of the tags of a specific ConferenceSession instance, which is pointed to by LocalCache. Notice that this specific example is the inverse of what we found with the dominator tree, if we explored this table enough we would end up at a ConferenceSessionLoader reference.\nThread Overview The thread overview is a helpful view when you are looking at contributors based on the execution of code. For example, if you have a JVM which has thrown an OutOfMemoryError, you can tell if some type of request caused a massive spike which caused the exhaustion of memory, or if the requests may have not been abnormal, there just wasn‚Äôt sufficient space to support the request.\nWarning It may be the case that the thread that has the OutOfMemoryError in its stack is not the root cause. Consider the following example:\n We have a max heap of 128 Mb. A request comes in that produces a 125Mb int[] A second request comes in that produces a 5Mb int[].  The JVM would potentially throw the OutOfMemory on that second request, since there‚Äôs not enough memory to allocate 5Mb, however, it might be the case that the code path for the initial request is allocating memory unnecessarily.\n OQL Another strong feature of Eclipse Memory Analyzer is the OQL studio to execute queries to do lookup on objects in your heap.\nLookup our ConferenceSession class type:\nSELECT * FROM INSTANCEOF cchesser.javaperf.workshop.data.ConferenceSession üí° To execute the query, you click on the red exclamation mark (‚ùó). Alternatively, you can press CTRL+Enter on Windows or Command+Enter on macOS.\nBy returning the raw type back, you can expand each one to further look at the contents of the object. If you wanted to just report the object with its title attribute and the object‚Äôs retained sized, you could do this:\nSELECT c.title.toString(), c.@retainedHeapSize FROM INSTANCEOF cchesser.javaperf.workshop.data.ConferenceSession c Now, you could then filter this by including a WHERE clause, where you can filter it by the title or the abstract:\nSELECT c.title.toString(), c.@retainedHeapSize FROM INSTANCEOF cchesser.javaperf.workshop.data.ConferenceSession c WHERE c.title.toString() LIKE \".*(J|j)ava.*\" OR c.abstract.toString() LIKE \".*(J|j)ava.*\" Reference: Eclipse Memory Analyzer OQL Syntax\nThe auto-completion will also let you invoke fields and method‚Äôs from Eclipse Mat‚Äôs own internal model for the heap dump. You can view other methods available by exploring the API Reference\nUseful Plugins Calcite MAT The Calcite MAT Plugin adds sort, group by and join behavior (among other things) and an additional SQL query engine.\nWe can use this plugin to do some more advanced analysis, for example:\n Getting a distribution of the number of tags in our ConferenceSessions  select getSize(c.tags) tag_cnt, count(getSize(c.tags)) from \"cchesser.javaperf.workshop.data.ConferenceSession\" c group by tag_cnt order by tag_cnt desc ¬† ¬†¬†Up Next In the next section, we'll continue our analysis in VisualVM. Visual VM   ","categories":"","description":"Heap Analysis using Eclipse MAT","excerpt":"Heap Analysis using Eclipse MAT","ref":"/docs/memory/mat/","tags":"","title":"Eclipse MAT"},{"body":"The Threads page provides a snaphost of all threads in our application, and we can use it to acquire information about computation and latency events.\nThread Chart We can use the Thread Chart view to select a region of time and view the state of threads and the most common stack frames for that particular time slice:\nWe can also edit the types of events shown by the chart. Right click on the chart, and select Edit Thread Activity Lanes\nWe can then narrow down on specific events.\nFor the purpose of this section filter on only the Sleep events. Then, select a period of time and look at what has caused our threads to go to sleep for that particular period:\nOnce you‚Äôre done with the filtered view, right click on the Thread page and Reset the page (to return to the default state).\nBy Thread We can select an invididual thread from the Thread Table to further filter the data just for that thread. From this filtered view, we can inspect what the commonly executed methods are for a particular thread.\nWe can then use the stacktrace view to correlate what piece of code executed the most.\n Explore There‚Äôs a couple of threads specifically created by our application, these are the wkshp-conf-loader named threads. The dw-* named threads are threads created by DropWizard to handle specific requests (you might have noticed this based on the name containing a REST Resource). Explore the state of some of these threads while thinking about the follow up questions.\n Follow Ups  Where are we spending most of our time sleeping? What is causing this? Are there any unnecessary method invocations? Are any threads doing work that isn‚Äôt visible?  ¬† ¬†¬†Up Next In the next section, we'll look at the Memory state of our application. Memory   ","categories":"","description":"Find the computation and latency events in your application.\n","excerpt":"Find the computation and latency events in your application.\n","ref":"/docs/jmc/threads/","tags":"","title":"Threads"},{"body":"The memory page shows us the overall memory usage and garbage collection events for our recording.\nThe Class Table lets us view the total memory allocation dedicated to particular instances of that class. Selecting a particular class will allow us to view what code paths are responsible for creating those objects.\nWe can also filter this view to a particular range in time, for example a range where we went from low to high heap usage:\nWe can then use this filtered view and drill down through the stack trace to find methods of interest:\n Explore Narrow down through some periods of time where our heap rose quickly and then was collected. Look at the memory reclaimed after each collection.\n Follow Ups  What are the most commonly allocated classes? Where do they come from? Are there any classes we own that are also high on the allocation list? Expand the memory usage chart and only chart the Used Heap, do you notice a pattern?  What do you think caused the flat line at the end of the chart?    ¬† ¬†¬†Up Next In the next section, we'll look at the I/O used by our application. I/O Operations   ","categories":"","description":"Find the memory cost of events in our application.\n","excerpt":"Find the memory cost of events in our application.\n","ref":"/docs/jmc/memory/","tags":"","title":"Memory"},{"body":" Note Make sure you‚Äôve gone through the Prerequisites  VisualVM is a tool which used to be part of Oracle‚Äôs JDK and is now a standalone tool. This tool was spawned from the Netbeans Profiler, and it has some helpful tools to inspect a heap dump.\nOpening Dumps To load the heap dump in VisualVM, you will just go to File -\u003e Load‚Ä¶ and specify the File Format to be Heap Dumps‚Ä¶.\nAnalyzing the Heap Dump VisualVM offers the following sections:\n Summary Objects Threads OQL Console R Console  For the purpose of this section we are only going to utilize the OQL Console to construct queries on the heap. There are other options in VisualVM (briefly discussed here), but we feel that the other tools presented before this offer much nicer views/data.\nSummary The Summary view gives you a quick overview of the state of the heap:\nThis view also lets you quickly gather the dominators for the heap, similar to the Dominator Tree in Eclipse MAT.\nObjects The Objects view groups instances by class.\nWithin this view, you can inspect individual instances of an object and see both the fields and the incoming references to that instance:\nThreads The Threads view visualizes the state of threads.\nWithin this view, you can drill down into certain threads and view what was specifically referenced in a stack frame:\nOQL Console One of the attractive features for VisualVM is that its OQL Console allows you to write Javascript code to query objects, which you can then do other functions on that data.\nFrom the OQL Console, we will issue queries and then allow you to further play around with the language.\nOQL Queries Note The OQL which you use between this tool (and others), isn‚Äôt necessarily standard, and therefore cannot be used between tooling without issues. VisualVM gives you the ability to leverage Javascript, which is unique to other tools supporting heap dump analysis.  Reference: VisualVM OQL Help\nDeamon Threads Query for Thread objects which are daemons (you can get context of Threads, since they are objects in your heap too):\nselect t from java.lang.Thread t where t.daemon == true Previous versions of VisualVM used to return the results as hyperlinks, which you could then click and begin diving into the instance state:\nThe newer versions of VisualVM will populate the results in a view similar to the Objects view:\nMapping to JSON Query for Thread objects (similar to last query), but return multiple attributes as JSON:\nselect {name: t.name.toString(), thread_id: t.tid } from java.lang.Thread t where t.daemon == true Applying Javascript VisualVM offers a helper object that represents the heap, the heap object, which offers a few useful functions.\nDuring our OQL searching, we‚Äôll be using heap.objects to gather the set of objects we want.\nWe‚Äôll start by limiting our objects to instances of cchesser.javaperf.workshop.data.ConferenceSession and assign it to a variable called sessions (which we‚Äôll reference later).\nvar sessions = heap.objects('cchesser.javaperf.workshop.data.ConferenceSession'); We‚Äôre going to find ConferenceSessions that which have tags, we‚Äôll do that by writing a Javascript function to filter results which have tags. We‚Äôll apply this filter to our sessions.\nvar sessions = heap.objects('cchesser.javaperf.workshop.data.ConferenceSession'); function hasTags(conf) { return conf.tags.size \u003e 0 } filter(sessions, hasTags); Take that previous query and further expand it to list it in JSON with the number of tags. It is often times convenient to have a reference to the object we‚Äôre interacting with, to more easily see the available fields.\nvar sessions = heap.objects('cchesser.javaperf.workshop.data.ConferenceSession'); function hasTags(conf) { return conf.tags.size \u003e 0 } var withTags = filter(sessions, hasTags); function toJSON(conf) { return { conference: conf , tagCount : conf.tags.size }; } map(withTags, toJSON); We can further expand this to sort the results, descending by number of tags, and list the tags in the results:\nvar sessions = heap.objects('cchesser.javaperf.workshop.data.ConferenceSession'); function hasTags(conf) { return conf.tags.size \u003e 0 } var withTags = filter(sessions, hasTags); function toJSON(conf) { return { conference: conf , tagCount : conf.tags.size }; } var confs = map(withTags, toJSON); function tagSorter(lhs, rhs) { return rhs.tagCount - lhs.tagCount; } sort(confs, tagSorter); We could also inline most of this using the inline syntax:\nfunction hasTags(conf) { return conf.tags.size \u003e 0 } sort(map(filter(heap.objects('cchesser.javaperf.workshop.data.ConferenceSession'), hasTags), '{ conference: it, tag_count: it.tags.size, tags: toArray(it.tags.elementData) }'), 'rhs.tag_count - lhs.tag_count') Useful Plugins OQL Syntax Support This plugin adds some auto complete and syntax highlighting to the OQL Console\n Challenge Apply what you‚Äôve learned about OQL in this section and write some javascript that will show the distribution of tag counts in our conference sessions (similar to what we did with calcite mat.)\nSample Solutions JSON Output This solution will return the result as a JSON object.\n function toggleContent(button) { var content = button.parentElement.getElementsByClassName('spoiler-content')[0]; content.hidden = !content.hidden; }  Show JSON var sessions = heap.objects('cchesser.javaperf.workshop.data.ConferenceSession'); function toJSON(conf) { return { conference: conf , tagCount : conf.tags ? conf.tags.size : 0, title: conf.title }; } var confs = map(sessions, toJSON); var results = {} var arr = toArray(confs) arr.length; for(var i = 0; i \u003c arr.length; i++) { var conf = arr[i]; if(!results[conf.tagCount]) { results[conf.tagCount] = 0; } results[conf.tagCount] = results[conf.tagCount] + 1; } results   HTML Output This solution will return the result as an HTML \u003cul\u003e.\n function toggleContent(button) { var content = button.parentElement.getElementsByClassName('spoiler-content')[0]; content.hidden = !content.hidden; }  Show HTML var sessions = heap.objects('cchesser.javaperf.workshop.data.ConferenceSession'); function toJSON(conf) { return { conference: conf , tagCount : conf.tags ? conf.tags.size : 0, title: conf.title }; } var confs = map(sessions, toJSON); var arr = toArray(confs) var maxSize = max(map(arr, 'it.tagCount')) var results = [] for(var i = 0; i \u003c maxSize+1; i++ ) { results[i] = 0; } for(var i = 0; i \u003c arr.length; i++) { var conf = arr[i]; results[conf.tagCount]++ } var report = \"\u003chtml\u003e\u003cul\u003e\"; for(var i = 0; i \u003c maxSize+1; i++) { var count = results[i]; report += \"\u003cli\u003e\u003cb\u003eSize(\" +i+\")\u003c/b\u003e=\"+count+\"\u003c/li\u003e\" } report+=\"\u003c/ul\u003e\u003c/html\u003e\" toHtml(report)   ¬† ¬†¬†Up Next In the next section, we'll test our knwolege. Memory Challenge   ","categories":"","description":"Heap Analysis using VisualVM","excerpt":"Heap Analysis using VisualVM","ref":"/docs/memory/visualvm/","tags":"","title":"Visual VM"},{"body":"The I/O pages can provide context of what external resources you are utilizing from you code base, and relate it to other latency events.\nFor the purpose of our workshop service, we are doing network I/O, and therefore will look at the Socket I/O page.\nFrom this page, we can gain context of what host(s) we are calling, with what frequency, and the cost associated with those calls:\nWe can then filter on a particular host and port and drill down into a particular piece of code responsible for that call:\n Explore Filter through the total I/O time and explore a couple of events with high I/O.\n Follow Ups  What remote services are we interacting with? How long are we interacting with them and how many invocations? How many times did we make calls and what threads were tied to those calls?  ","categories":"","description":"Find the interactions with external resources.\n","excerpt":"Find the interactions with external resources.\n","ref":"/docs/jmc/io_operations/","tags":"","title":"I/O Operations"},{"body":"The provided WorkshopService has an intentional memory problem, use the previous sections as reference to try to pin point it.\nTips  With the Dominator Tree (Eclipse MAT) determine what object would free up the most memory (if we could get rid of it) With the Histogram (Eclipse MAT) determine what type of object has the most instances  Using the Incoming Objects view, find out what‚Äôs pointing to them.    Once you‚Äôve found the large object, look through it‚Äôs properties and determine why this object holds on to so many other objects.\nSolution This section contains a solution, make sure you‚Äôve given things a shot before spoiling the fun.   function toggleContent(button) { var content = button.parentElement.getElementsByClassName('spoiler-content')[0]; content.hidden = !content.hidden; }  Show Solution Dominator Tree A first glance at the dominator tree will point us to a io.dropwizard.jetty.MutableServletContextHandler, which is something controlled by the DropWizard framework. Let‚Äôs dig through its references until we find some classes in the cchesser package.\nThe first instance of a class we ‚Äúown‚Äù is cchesser.javaperf.workshop.resources.WorkshopResource\nLet‚Äôs look at it‚Äôs properties a bit, and we‚Äôll find a cchesser.javaperf.workshop.cache.CleverCache reference with about 70% of the memory consumption.\nWe‚Äôll look at its properties in a bit more detail in the following sections.\nHistogram View A first glance at the Histogram View (sorted by retained heap), shows us about 2,000,000 instances of cchesser.javaperf.workshop.data.Searcher$SearchResultElement\nLooking through the references to an instance of this type, we end up being referenced by the data field in cchesser.javaperf.workshop.cache.CleverCache$CacheEntry\nWe can further inspect the Incoming References for a particular entry, and see what is pointing to it, tracing it back to something we own:\nOnce again, we‚Äôve ended up at cchesser.javaperf.workshop.resources.WorkshopResource, specifically a field called resultsByContext.\nWe‚Äôll take a closer look at this cchesser.javaperf.workshop.cache.CleverCache object.\nInspecting Clever Cache First, lets determine how many instances of cchesser.javaperf.workshop.cache.CleverCache we have. We‚Äôve found a single instance that is about 70Mb (in our sample dump), so let‚Äôs double check if there‚Äôs more of these.\nWe can do that in a couple of ways:\n Use the histogram view to filter on CleverCache  Use OQL to find instances of that object:  select * from cchesser.javaperf.workshop.cache.CleverCache Fields/References We can find the fields and references for an instance using either Eclipse MAT or VisualVM.\nIn Eclipse Mat, the fields for an instance display in an Attributes tab\nIn VisualVM, we can load the Objects view and apply a filter on class name to then inspect the fields and references\nLooking at the properties, we find that there‚Äôs a cacheLimit of 250. Let‚Äôs find out exactly how many entries are in the cache (the innerCache field).\nFinding Sizes Let‚Äôs write a query that will show us what the count of entries in the cache is.\n For our query, we need to pull the cacheLimit and size of the innerCache map,  We can do this a few ways:\nEclipse MAT / OQL we can do that with the following query:\nSELECT c.cacheLimit AS \"max entries\", c.innerCache.size AS entries FROM cchesser.javaperf.workshop.cache.CleverCache c Eclipse MAT / Calcite select c.cacheLimit as \"max entries\", getSize(c.innerCache) as \"entries\" from cchesser.javaperf.workshop.cache.CleverCache c VisualVM / OQL var caches = heap.objects(\"cchesser.javaperf.workshop.cache.CleverCache\") function report(cache) { return { maxEntries: cache.cacheLimit, entries: cache.innerCache.size } } map(caches, report) That doesn‚Äôt seem right at all, we want at most 250 items but we have about 10,000. Let‚Äôs find out why that is the case.\n Memory Problem Explained The interaction between the WorkshopResource and CleverCache happens through the /search resource.\ncchesser.javaperf.workshop.WorkshopResource\n@GET @Path(\"/search\") @Produces(MediaType.APPLICATION_JSON) @Timed public Searcher.SearchResult searchConference(@QueryParam(\"q\") String term, @QueryParam(\"c\") String context) { return fetchResults(term, context); } private Searcher.SearchResult fetchResults(String term, String context) { if (context != null \u0026\u0026 !context.isEmpty()) { if (resultsByContext.exists(context)) { return resultsByContext.fetch(context); } } // does not exist in cache, compute and store  SearchResult results = searcher.search(term); resultsByContext.store(results.getResultsContext(), results); return results; } If a context is sent, the previously cached values for the search are returned, otherwise we cache those result values in case they need to be referenced again.\njavaperf.workshop.cache.CleverCache\n/** * Stores the given key value pair in the cache * * @param key the unique identifier associated with the given value * @param value the value mapped to the given key */ public void store(K key, V value) { if (isFull()) { K keyToRemove = getLFUKey(); CleverCache\u003cK, V\u003e.CacheEntry\u003cV\u003e removedEntry = innerCache.remove(keyToRemove); } CacheEntry\u003cV\u003e newEntry = new CacheEntry\u003cV\u003e(); newEntry.data = value; newEntry.frequency = 0; innerCache.put(key, newEntry); } // other methods  private boolean isFull() { return innerCache.size() == cacheLimit; } This interaction is NOT thread safe. Consider this scenario:\n Thread 1 invokes store when the innerCache.size() is 249  isFull() evaluates to false Execution halts prior to innerCache.put   Thread 2 invokes store when the innerCache.size() is 249  isFull() evaluates to false Execution halts prior to innerCache.put   Thread 1 resumes and executes innerCache.put, innerCache.size() is now 250 Thread 2 resumes and executes innerCache.put, innerCache.size() is now 251 For the lifecycle of the jvm isFull() will no longer return true  Fortunately, the DropWizard documentation calls out the need to consider thread safety:\nSince the WorkshopResource has a resultsByContext field that will get shared across threads, that type should be thread safe.\nPotential Solutions   The naive solution would be to just change isFull() to consider \u003e=, though that might lead to ConcurrentModificationExceptions\n  The proper solution would be to make the class Thread Safe\n    ¬† ¬†¬†Up Next In the next section, we'll continue learn about Garbage Collection logs. Garbage Collections   ","categories":"","description":"Put all the pieces together with this challenge to test your skills","excerpt":"Put all the pieces together with this challenge to test your skills","ref":"/docs/memory/challenge/","tags":"","title":"Memory Challenge"},{"body":"A key piece to understanding what is happening in terms of GC cycles within your service, is enabling GC logs. In this section, we are going to do some analysis on the JVM in regards to it‚Äôs garbage collection (GC) cycles.\nPrerequisite R environment (If you want to try parsing some of the logs)  GC JVM Options Here is a set of JVM options you can enable on your service and how to interpret those logs.\n -XX:+PrintGCDetails: Includes more details within your GC log -XX:+PrintGCDateStamps: Have a readable date/time string to correlate events in your log. Without this option, your GC log will have elapsed time since the JVM was started. This format (which is reported) in seconds (with millisecond precision), is not easy for someone to quickly correlate when this event was logged (as you have to infer the time based on when the JVM was started). -Xloggc: Specifies the log file for the garbage collection logs (otherwise will go to stdout). üí° Note: -verbose:gc is NOT necessary when you set Xloggc (it is implied). -XX:+UseGCLogFileRotation: Support rotating your GC log file (you don‚Äôt want to let this get too big). -XX:GCLogFileSize: Size of the file for rotation (ex. 10M). -XX:NumberOfGCLogFiles: Number of GC log files to maintain (ex. 3). üí° Note: if you are monitoring your log file with another solution (like splunk or logstash), you typically don‚Äôt need to be keeping an inventory of rolled files around, unless you are concerned about log forwarding failing and want to ensure a given amount is still capable of being captured from a host.  GC Log formats With different garbage collectors in the JVM, you will get slightly different GC log formats.\nParallel GC 2015-09-30T10:57:20.215+0600: 0.847: [GC (Allocation Failure) [PSYoungGen: 65536K-\u003e10748K(76288K)] 65536K-\u003e12607K(251392K), 0.0118637 secs] [Times: user=0.03 sys=0.01, real=0.01 secs] 2015-09-30T10:57:20.556+0600: 1.188: [GC (Metadata GC Threshold) [PSYoungGen: 44312K-\u003e10748K(141824K)] 46171K-\u003e12786K(316928K), 0.0077755 secs] [Times: user=0.03 sys=0.00, real=0.01 secs] 2015-09-30T10:57:20.564+0600: 1.196: [Full GC (Metadata GC Threshold) [PSYoungGen: 10748K-\u003e0K(141824K)] [ParOldGen: 2038K-\u003e10444K(116736K)] 12786K-\u003e10444K(258560K), [Metaspace: 20976K-\u003e20976K(1067008K)], 0.0286381 secs] [Times: user=0.14 sys=0.01, real=0.03 secs] Concurrent Mark Sweep 2015-09-30T11:11:35.994+0600: 0.838: [GC (Allocation Failure) 0.838: [ParNew: 69952K-\u003e8703K(78656K), 0.0128204 secs] 69952K-\u003e12781K(253440K), 0.0128848 secs] [Times: user=0.04 sys=0.01, real=0.01 secs] 2015-09-30T11:11:38.009+0600: 2.853: [GC (CMS Initial Mark) [1 CMS-initial-mark: 4077K(174784K)] 67493K(253440K), 0.0088311 secs] [Times: user=0.04 sys=0.00, real=0.01 secs] 2015-09-30T11:11:38.018+0600: 2.862: [CMS-concurrent-mark-start] 2015-09-30T11:11:38.018+0600: 2.862: [CMS-concurrent-mark: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 2015-09-30T11:11:38.018+0600: 2.862: [CMS-concurrent-preclean-start] 2015-09-30T11:11:38.019+0600: 2.863: [CMS-concurrent-preclean: 0.001/0.001 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] 2015-09-30T11:11:38.019+0600: 2.863: [CMS-concurrent-abortable-preclean-start] CMS: abort preclean due to time 2015-09-30T11:11:43.074+0600: 7.918: [CMS-concurrent-abortable-preclean: 1.233/5.055 secs] [Times: user=1.23 sys=0.01, real=5.06 secs] 2015-09-30T11:11:43.074+0600: 7.918: [GC (CMS Final Remark) [YG occupancy: 63415 K (78656 K)]7.918: [Rescan (parallel) , 0.0052614 secs]7.924: [weak refs processing, 0.0000337 secs]7.924: [class unloading, 0.0029068 secs]7.927: [scrub symbol table, 0.0025781 secs]7.929: [scrub string table, 0.0002699 secs][1 CMS-remark: 4077K(174784K)] 67493K(253440K), 0.0117740 secs] [Times: user=0.04 sys=0.01, real=0.01 secs] 2015-09-30T11:11:43.086+0600: 7.930: [CMS-concurrent-sweep-start] 2015-09-30T11:11:43.086+0600: 7.930: [CMS-concurrent-sweep: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 2015-09-30T11:11:43.087+0600: 7.930: [CMS-concurrent-reset-start] 2015-09-30T11:11:43.110+0600: 7.954: [CMS-concurrent-reset: 0.023/0.023 secs] [Times: user=0.01 sys=0.01, real=0.03 secs] G1 015-09-30T11:13:03.870+0600: 0.395: [GC pause (G1 Evacuation Pause) (young), 0.0052206 secs] [Parallel Time: 1.9 ms, GC Workers: 8] [GC Worker Start (ms): Min: 395.4, Avg: 395.5, Max: 395.8, Diff: 0.3] [Ext Root Scanning (ms): Min: 0.0, Avg: 0.3, Max: 1.1, Diff: 1.1, Sum: 2.0] [Update RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0] [Processed Buffers: Min: 0, Avg: 0.0, Max: 0, Diff: 0, Sum: 0] [Scan RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.1] [Code Root Scanning (ms): Min: 0.0, Avg: 0.1, Max: 0.4, Diff: 0.4, Sum: 0.5] [Object Copy (ms): Min: 0.7, Avg: 1.4, Max: 1.6, Diff: 0.9, Sum: 11.4] [Termination (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.1] [GC Worker Other (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.1] [GC Worker Total (ms): Min: 1.5, Avg: 1.8, Max: 1.8, Diff: 0.3, Sum: 14.2] [GC Worker End (ms): Min: 397.3, Avg: 397.3, Max: 397.3, Diff: 0.0] [Code Root Fixup: 0.1 ms] [Code Root Purge: 0.1 ms] [Clear CT: 0.1 ms] [Other: 3.0 ms] [Choose CSet: 0.0 ms] [Ref Proc: 2.7 ms] [Ref Enq: 0.0 ms] [Redirty Cards: 0.2 ms] [Humongous Reclaim: 0.0 ms] [Free CSet: 0.0 ms] [Eden: 24.0M(24.0M)-\u003e0.0B(39.0M) Survivors: 0.0B-\u003e3072.0K Heap: 24.0M(256.0M)-\u003e5754.5K(256.0M)] [Times: user=0.02 sys=0.01, real=0.00 secs] 2015-09-30T11:13:04.343+0600: 0.868: [GC pause (G1 Evacuation Pause) (young), 0.0082908 secs] [Parallel Time: 5.1 ms, GC Workers: 8] [GC Worker Start (ms): Min: 868.3, Avg: 868.4, Max: 868.8, Diff: 0.5] [Ext Root Scanning (ms): Min: 0.0, Avg: 0.3, Max: 1.7, Diff: 1.7, Sum: 2.7] [Update RS (ms): Min: 0.0, Avg: 0.1, Max: 0.2, Diff: 0.2, Sum: 0.5] [Processed Buffers: Min: 0, Avg: 0.4, Max: 1, Diff: 1, Sum: 3] [Scan RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.1] [Code Root Scanning (ms): Min: 0.0, Avg: 0.4, Max: 1.4, Diff: 1.4, Sum: 3.5] [Object Copy (ms): Min: 3.2, Avg: 4.0, Max: 4.6, Diff: 1.4, Sum: 32.1] [Termination (ms): Min: 0.0, Avg: 0.1, Max: 0.1, Diff: 0.1, Sum: 0.6] [GC Worker Other (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.1] [GC Worker Total (ms): Min: 4.6, Avg: 4.9, Max: 5.0, Diff: 0.5, Sum: 39.5] [GC Worker End (ms): Min: 873.3, Avg: 873.3, Max: 873.4, Diff: 0.0] [Code Root Fixup: 0.3 ms] [Code Root Purge: 0.1 ms] [Clear CT: 0.1 ms] [Other: 2.7 ms] [Choose CSet: 0.0 ms] [Ref Proc: 2.4 ms] [Ref Enq: 0.0 ms] [Redirty Cards: 0.1 ms] [Humongous Reclaim: 0.0 ms] [Free CSet: 0.1 ms] [Eden: 39.0M(39.0M)-\u003e0.0B(147.0M) Survivors: 3072.0K-\u003e6144.0K Heap: 44.6M(256.0M)-\u003e13.9M(256.0M)] [Times: user=0.04 sys=0.00, real=0.01 secs] 2015-09-30T11:13:04.650+0600: 1.176: [GC pause (Metadata GC Threshold) (young) (initial-mark), 0.0090083 secs] [Parallel Time: 5.5 ms, GC Workers: 8] [GC Worker Start (ms): Min: 1175.9, Avg: 1176.0, Max: 1176.0, Diff: 0.1] [Ext Root Scanning (ms): Min: 1.1, Avg: 1.2, Max: 1.4, Diff: 0.3, Sum: 9.4] [Update RS (ms): Min: 0.0, Avg: 0.1, Max: 0.2, Diff: 0.2, Sum: 1.2] [Processed Buffers: Min: 0, Avg: 1.1, Max: 2, Diff: 2, Sum: 9] [Scan RS (ms): Min: 0.1, Avg: 0.1, Max: 0.3, Diff: 0.2, Sum: 1.1] [Code Root Scanning (ms): Min: 0.0, Avg: 0.2, Max: 0.5, Diff: 0.5, Sum: 2.0] [Object Copy (ms): Min: 3.4, Avg: 3.7, Max: 3.8, Diff: 0.4, Sum: 29.3] [Termination (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0] [GC Worker Other (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.2] [GC Worker Total (ms): Min: 5.4, Avg: 5.4, Max: 5.5, Diff: 0.1, Sum: 43.3] [GC Worker End (ms): Min: 1181.4, Avg: 1181.4, Max: 1181.4, Diff: 0.0] [Code Root Fixup: 0.3 ms] [Code Root Purge: 0.0 ms] [Clear CT: 0.1 ms] [Other: 3.0 ms] [Choose CSet: 0.0 ms] [Ref Proc: 2.7 ms] [Ref Enq: 0.0 ms] [Redirty Cards: 0.1 ms] [Humongous Reclaim: 0.0 ms] [Free CSet: 0.1 ms] [Eden: 33.0M(147.0M)-\u003e0.0B(140.0M) Survivors: 6144.0K-\u003e13.0M Heap: 46.9M(256.0M)-\u003e20.9M(256.0M)] [Times: user=0.04 sys=0.00, real=0.01 secs] 2015-09-30T11:13:04.660+0600: 1.185: [GC concurrent-root-region-scan-start] 2015-09-30T11:13:04.664+0600: 1.190: [GC concurrent-root-region-scan-end, 0.0046509 secs] 2015-09-30T11:13:04.664+0600: 1.190: [GC concurrent-mark-start] 2015-09-30T11:13:04.665+0600: 1.190: [GC concurrent-mark-end, 0.0007287 secs] 2015-09-30T11:13:04.665+0600: 1.190: [GC remark 1.190: [Finalize Marking, 0.0001736 secs] 1.191: [GC ref-proc, 0.0000411 secs] 1.191: [Unloading, 0.0016740 secs], 0.0020377 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] 2015-09-30T11:13:04.667+0600: 1.193: [GC cleanup 21M-\u003e14M(256M), 0.0004254 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] Type of Collections A simple rule to watch for on your logs is the prefix of either:\n[GC ... \u003c- Minor GC cycle (young gen) [Full GC ... \u003c- Full GC cycle (‚ùó) Explicit GCs can also be identified, which is when something is invoking the System.gc() API. Note, this is not good thing, as something is forcing a GC cycle to occur, rather than letting the JVM trigger this on its own (what should naturally occur).\n2015-09-30T12:23:44.425+0600: 195.699: [GC (System.gc()) [PSYoungGen: 39223K-\u003e3562K(76288K)] 49685K-\u003e14032K(190464K), 0.0047880 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] 2015-09-30T12:23:44.430+0600: 195.704: [Full GC (System.gc()) [PSYoungGen: 3562K-\u003e0K(76288K)] [ParOldGen: 10469K-\u003e9174K(114176K)] 14032K-\u003e9174K(190464K), [Metaspace: 25137K-\u003e25137K(1071104K)], 0.0724521 secs] [Times: user=0.38 sys=0.01, real=0.07 secs] It is generally recommended to use the -XX:+DisableExplicitGC JVM option to disable forceful GC events. This will allow the JVM to still have garbage collections, but it disables them from being triggered explicitly. The description of this option:\n By default calls to System.gc() are enabled (-XX:-DisableExplicitGC). Use -XX:+DisableExplicitGC to disable calls to System.gc(). Note that the JVM still performs garbage collection when necessary.\n Gathering GC Logs Enabling logs With our service, let‚Äôs go ahead and start it up with GC logging enabled:\n# Navigate to the root directory of this project java -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:gc.log -XX:GCLogFileSize=5M -XX:NumberOfGCLogFiles=2 \\  -jar java-perf-workshop-server/target/java-perf-workshop-server-1.1.0-SNAPSHOT.jar server server.yml Parsing the log For parsing the logs, we are just going to show a simple approach using R to parse the gc.log that we created. To do this, we will use the stringr package.\n# Including stringr package for regex library(stringr) # Navigating to where the project is at on my filesystem setwd(\"~/java-perf-workshop\") # Read the GC log file in gc \u003c- readLines(\"gc.log\") # Regex the matches matches \u003c- str_match(gc, \"(\\\\d+)K-\u003e(\\\\d+)K\\\\((\\\\d+)K\\\\),\\\\s(\\\\d+.\\\\d+)\\\\ssecs.*\\\\[Times\\\\: user=(\\\\d+.\\\\d+) sys=(\\\\d+.\\\\d+), real=(\\\\d+.\\\\d+) secs\") # Look at what matches, now we want to filter out the NA matches # Filter content out and convert to a data frame gc.df \u003c- data.frame(na.omit(matches[,-1]), stringsAsFactors=FALSE) # Add a column header to describe fields colnames(gc.df) \u003c- c(\"HeapUsedBeforeGC_KB\",\"HeapUsedAfterGC_KB\", \"HeapCapacity_KB\", \"GCPauseTime_Sec\", \"GCUserTime_Sec\", \"GCSysTime_Sec\", \"GCRealTime_Sec\") # List out the contents of the data frame gc.df Example output:\n HeapUsedBeforeGC_KB HeapUsedAfterGC_KB HeapCapacity_KB GCPauseTime_Sec GCUserTime_Sec GCSysTime_Sec GCRealTime_Sec 1 65536 12554 251392 0.0091645 0.03 0.01 0.01 2 45883 12707 316928 0.0092271 0.03 0.01 0.01 Reminder on the types of time being collected:\n GCUserTime_Sec: User space time GCSysTime_Sec: Kernel space time (operating system) GCRealTime_Sec: Complete time taken  Notice that the GCRealTime_Sec should closely align with the GCPauseTime_Sec value (just rounded up). If you notice that the GCUserTime_Sec is much larger than the GCRealTime_Sec, you can conclude that multiple threads are executing garbage collection, as GCUserTime_Sec is just the sum time of all the threads.\nExternal Tools GC Easy There‚Äôs an existing tool GC Easy which will do GC log parsing and analysis as well.\n","categories":"","description":"Analyzing garbage collections of the JVM","excerpt":"Analyzing garbage collections of the JVM","ref":"/docs/memory/gc/","tags":"","title":"Garbage Collections"},{"body":"In this workshop, we will be getting more familiar with using Java Mission Control and the Flight Recorder. As we have been running our service, we want to gather more insight of the code in the service by running series of simple tests and measuring the service.\n","categories":"","description":"Initial look at the JVM from its native perspective.\n","excerpt":"Initial look at the JVM from its native perspective.\n","ref":"/docs/jmc/","tags":"","title":"Java Mission Control \u0026 Flight Recorder"},{"body":" JDK Mission Control User Guide Hunting down code hotspots with JFR  ","categories":"","description":"Collection of useful references used to build this guide.\n","excerpt":"Collection of useful references used to build this guide.\n","ref":"/docs/jmc/_references/","tags":"","title":"References"},{"body":"","categories":"","description":"Analyzing the JVM heap with available tooling.","excerpt":"Analyzing the JVM heap with available tooling.","ref":"/docs/memory/","tags":"","title":"Memory Analysis"},{"body":"Contributors   Carl Chesser Profile    Jan Monterrubio Profile      ","categories":"","description":"","excerpt":"Contributors   Carl Chesser Profile    Jan Monterrubio Profile      ","ref":"/contributors/","tags":"","title":"Contributors"},{"body":"  #td-cover-block-0 { background-image: url(/featured-background_hu323b48cd362fa81e6f4359eed091efb0_172516_960x540_fill_q75_catmullrom_top.jpg); } @media only screen and (min-width: 1200px) { #td-cover-block-0 { background-image: url(/featured-background_hu323b48cd362fa81e6f4359eed091efb0_172516_1920x1080_fill_q75_catmullrom_top.jpg); } }  Understand how your JVM works. Get Started   Download   An open-source guide that steps through how to use open-source tooling to inspect and troubleshoot the performance of your Java applications.\n         This workshop focuses on taking an example Java web service, which performs suboptimally, and explores its behavior with open source tooling. This workshop is intended to empower developers with essential skills of measuring how the an application in the JVM performs. While this can become an advanced topic for tuning application, this workshop focuses on simple approaches with free available tooling.\n      Basics with OS, processes, and threads Start with basic knowledge of how to assess your Java application from the perspective of the operating system with processes, threads, and system calls.\nRead more ‚Ä¶\n   Java Mission Control Learn how to levarage Java Mission Control with Flight Recorder to get insight into your running application.\nRead more ‚Ä¶\n   Memory Analysis Learn how to explore the memory utilized in your Java application. This includes how to enable and explore the garbage collection logs.\nRead more ‚Ä¶\n    ","categories":"","description":"","excerpt":"  #td-cover-block-0 { background-image: ‚Ä¶","ref":"/","tags":"","title":"jvmperf"}]